// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: key_find_for_credit_refills.sql

package db

import (
	"context"
	"database/sql"
)

const findKeysForRefill = `-- name: FindKeysForRefill :many
SELECT
  k.id, k.key_auth_id, k.hash, k.start, k.workspace_id, k.for_workspace_id, k.name, k.owner_id, k.identity_id, k.meta, k.expires, k.created_at_m, k.updated_at_m, k.deleted_at_m, k.refill_day, k.refill_amount, k.last_refill_at, k.enabled, k.remaining_requests, k.ratelimit_async, k.ratelimit_limit, k.ratelimit_duration, k.environment,
  w.id, w.org_id, w.name, w.plan, w.tier, w.stripe_customer_id, w.stripe_subscription_id, w.beta_features, w.features, w.subscriptions, w.enabled, w.delete_protection, w.created_at_m, w.updated_at_m, w.deleted_at_m
FROM ` + "`" + `keys` + "`" + ` k
JOIN workspaces w ON k.workspace_id = w.id
WHERE
  k.deleted_at_m IS NULL
  AND k.refill_amount IS NOT NULL
  AND k.refill_amount > k.remaining_requests
  AND CASE
    WHEN ? THEN
      -- If today is last day of month, include keys with refill_day > today OR regular refill condition
      (k.refill_day > ? OR k.refill_day IS NULL OR k.refill_day = ?)
    ELSE
      -- Otherwise, only include keys matching regular refill condition
      (k.refill_day IS NULL OR k.refill_day = ?)
    END
`

type FindKeysForRefillParams struct {
	IsLastDayOfMonth interface{}   `db:"is_last_day_of_month"`
	Today            sql.NullInt16 `db:"today"`
}

type FindKeysForRefillRow struct {
	Key       Key       `db:"key"`
	Workspace Workspace `db:"workspace"`
}

// FindKeysForRefill
//
//	SELECT
//	  k.id, k.key_auth_id, k.hash, k.start, k.workspace_id, k.for_workspace_id, k.name, k.owner_id, k.identity_id, k.meta, k.expires, k.created_at_m, k.updated_at_m, k.deleted_at_m, k.refill_day, k.refill_amount, k.last_refill_at, k.enabled, k.remaining_requests, k.ratelimit_async, k.ratelimit_limit, k.ratelimit_duration, k.environment,
//	  w.id, w.org_id, w.name, w.plan, w.tier, w.stripe_customer_id, w.stripe_subscription_id, w.beta_features, w.features, w.subscriptions, w.enabled, w.delete_protection, w.created_at_m, w.updated_at_m, w.deleted_at_m
//	FROM `keys` k
//	JOIN workspaces w ON k.workspace_id = w.id
//	WHERE
//	  k.deleted_at_m IS NULL
//	  AND k.refill_amount IS NOT NULL
//	  AND k.refill_amount > k.remaining_requests
//	  AND CASE
//	    WHEN ? THEN
//	      -- If today is last day of month, include keys with refill_day > today OR regular refill condition
//	      (k.refill_day > ? OR k.refill_day IS NULL OR k.refill_day = ?)
//	    ELSE
//	      -- Otherwise, only include keys matching regular refill condition
//	      (k.refill_day IS NULL OR k.refill_day = ?)
//	    END
func (q *Queries) FindKeysForRefill(ctx context.Context, db DBTX, arg FindKeysForRefillParams) ([]FindKeysForRefillRow, error) {
	rows, err := db.QueryContext(ctx, findKeysForRefill,
		arg.IsLastDayOfMonth,
		arg.Today,
		arg.Today,
		arg.Today,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FindKeysForRefillRow
	for rows.Next() {
		var i FindKeysForRefillRow
		if err := rows.Scan(
			&i.Key.ID,
			&i.Key.KeyAuthID,
			&i.Key.Hash,
			&i.Key.Start,
			&i.Key.WorkspaceID,
			&i.Key.ForWorkspaceID,
			&i.Key.Name,
			&i.Key.OwnerID,
			&i.Key.IdentityID,
			&i.Key.Meta,
			&i.Key.Expires,
			&i.Key.CreatedAtM,
			&i.Key.UpdatedAtM,
			&i.Key.DeletedAtM,
			&i.Key.RefillDay,
			&i.Key.RefillAmount,
			&i.Key.LastRefillAt,
			&i.Key.Enabled,
			&i.Key.RemainingRequests,
			&i.Key.RatelimitAsync,
			&i.Key.RatelimitLimit,
			&i.Key.RatelimitDuration,
			&i.Key.Environment,
			&i.Workspace.ID,
			&i.Workspace.OrgID,
			&i.Workspace.Name,
			&i.Workspace.Plan,
			&i.Workspace.Tier,
			&i.Workspace.StripeCustomerID,
			&i.Workspace.StripeSubscriptionID,
			&i.Workspace.BetaFeatures,
			&i.Workspace.Features,
			&i.Workspace.Subscriptions,
			&i.Workspace.Enabled,
			&i.Workspace.DeleteProtection,
			&i.Workspace.CreatedAtM,
			&i.Workspace.UpdatedAtM,
			&i.Workspace.DeletedAtM,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
